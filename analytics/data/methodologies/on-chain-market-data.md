# On-chain market data

### Introduction

This artlicle intends to explain the data structure format of the on-chain raw data output generated by the open source Ethereum blockchain ETL tool called [Ethereum ETL](https://ethereum-etl.readthedocs.io/en/latest/). We, in [Credmark](https://credmark.com), internally call this raw blockchain data as ‘’First Order Data’’. This document also gives a summary of the on-chain data extraction process. For interaction with smart contracts we have used web3.py python library and [Infura API](https://infura.io) to establish the connection with the ethereum network node.

Additionally, this document also explains the methods to fetch Pricing data of underlying assets across different protocols along with some sample outputs which can help us understand the spread of the price of a single asset across the protocols on the ETH chain.

### First Order Data (Raw Ethereum Data)

First Order Data is the raw blockchain data that is fetched and stored by Ethereum ETL software . The data is stored in five categories, namely blocks, contracts, logs, receipts and transactions.

![Structure of directories for Ethereum ETL Data](https://lh6.googleusercontent.com/\_tsqI6Xe43ZrnfYpHo\_X3OpK1Qx8O\_vlQ3Qi64053bzwgpFmzN-KikMOV9zgcbwedT6-ECraWJ7V\_6V5IKm28zGO1YHfgEDRvvTSh8LXc0p2c9kHbITRZriZ0msg0eQJgYN0SmOa)

Data is downloaded by EthereumETL in batches on the basis of block number specified by the user while setting up the node categorized.

Example below shows structure of output data received by running Ethereum ETL for block range specified for each category of the raw data.

![Blocks used for this example](https://lh6.googleusercontent.com/6y8dqvFTxWkWDZPj1r2Wab83GVmyF6UhFTigKBJCaaS8uErOCeUli0-N\_4keZcURW3V3cDO8FyBEYxg0cn3S0OIHdlboqfaGcEAwWYXfMl07Og0390p31ZK-EvxnBg1tBWs9ajCF)

Let’s go over each data category(as shown in folder structure above) one by one:

1. **Blocks**

Sample file for blocks data obtained from EthereumETL available here: **** [**Blocks**](https://docs.google.com/spreadsheets/d/1Wtz0quf3DGf5DR-WUrrhH7rHTP0ub17z/edit?usp=sharing\&ouid=111243948991392403955\&rtpof=true\&sd=true)****

The details of columns in the blocks.csv are as follows :

* _**number**_ -  the block number. null when its pending block
* _**hash**_ - hash of the block. null when its pending block.
* _**parent\_hash**_  - hash of the parent block.
* _**nonce**_ - hash of the generated proof-of-work. null when its pending block.
* _**sha3\_uncles**_ - SHA3 of the uncles data in the block.
* _**logs\_bloom**_ - the bloom filter for the logs of the block. null when its pending block
* _**transactions\_root**_ -  the root of the transaction trie of the block.
* _**state\_root**_ - the root of the final state trie of the block.
* _**receipts\_root**_ - the root of the receipts trie of the block.
* _**miner**_ - the address of the beneficiary to whom the mining rewards were given.
* _**difficulty**_ - integer of the difficulty for this block.
* _**total\_difficulty**_ - integer of the total difficulty of the chain until this block.  &#x20;
* _**size**_ - integer the size of this block in bytes.
* _**extra\_data**_ - the "extra data" field of this block.
* _**gas\_limit**_ -  the maximum gas allowed in this block
* _**gas\_used**_ -  the total used gas by all transactions in this block.
* _**timestamp**_ -  the unix timestamp for when the block was collated.
* _**transaction\_count**_ - the number of transactions included in this block
* _**base\_fee\_per\_gas**_ - the minimum price per unit of gas for inclusion in this block, calculated by the network based on demand for block space.

**2. Contracts**

Sample file for contracts data obtained from EthereumETL available here: **** [**Contracts**](https://docs.google.com/spreadsheets/d/1srer-U6u3kQYCKZtSgn9rpZvRR9r-\_hj/edit?usp=sharing\&ouid=111243948991392403955\&rtpof=true\&sd=true)****

The  details of columns in the contracts.csv are as follows:&#x20;

* _**address**_ - the address of the smart contract. null when its pending block
* _**bytecode**_ - the code stored on-chain that describes a smart contract.&#x20;
* _**function\_sighashes**_ - all function signature hashes of the contract
* _**is\_erc20**_ - boolean variable describing whether the contract follows erc\_20
* _**is\_erc721**_ - boolean variable describing whether the contract follows erc\_721
* _**block\_number**_ - the block number in which the contract was pushed on network

3\. **Logs**

Sample file for logs data obtained from EthereumETL is available here: [**Logs**](https://drive.google.com/file/d/1htjHc20bVOgeNvgIpoXgqwrPG0evngXQ/view?usp=sharing)****

The details of columns in the logs.csv are as follows:

* _**log\_index** _ - Integer of the event index position in the block.
* _**transaction\_hash**_ - Hash of the transaction this event was created in.
* _**transaction\_index**_ - Integer of the transaction’s index position, the event was created in.
* _**block\_hash**_ - Hash of the block where this event was created in. null if still pending.
* _**block\_number**_ - The block number where this log was created in. null if still pending.
* _**address**_ - From which this event originated from.
* _**data**_ - The data containing non-indexed log parameters.
* _**topics**_ -  An array with max 4 32 Byte topics, topic 1-3 contains indexed parameters of the log. topic 0 is the event id.

4\. **Receipts**

Sample file for receipts data obtained from EthereumETL is available here:  [**Receipts**](https://drive.google.com/file/d/1HtGwZ4kAyEe-hg2-l-c5erkbLHrR41Az/view?usp=sharing)  &#x20;

The  details of columns in the receipts.csv are as follows:

* _**transaction\_hash**_ - Hash of the transaction.
* _**transaction\_index**_ - Integer of the transactions index position in the block.
* _**block\_hash**_ - Hash of the block where this transaction was in.
* _**block\_number**_ - Block number where this transaction was in.
* _**cumulative\_gas\_used**_ - The total amount of gas used when this transaction was executed in the block.
* _**gas\_used**_ - The amount of gas used by this specific transaction alone.
* _**contract\_address**_ - The contract address created, if the transaction was a contract creation, otherwise null.
* _**root**_ -  the root of the final state trie of the transaction.
* _**status**_ - TRUE if the transaction was successful, FALSE if the EVM reverted the transaction.
* _**effective\_gas\_price**_ - Price of the gas denoted in small fractions of ether called gwei.

5\. Transactions

Sample file for transactions data obtained from EthereumETL is available here: **** [**Transactions**   ](https://drive.google.com/file/d/1dGfRXeEXDgYqpA33nWUTbQUGTFOimhyX/view?usp=sharing)

The  details of columns in the transactions’ csv are as follows-

* _**hash**_ -     Hash of the transaction.
* _**nonce**_ - The number of transactions made by the sender prior to this one.
* _**block\_hash**_ - Hash of the block where this transaction was in. null if pending.
* _**block\_number**_ - Block number where this transaction was in. null if pending.
* _**transaction\_index**_ - Integer of the transactions index position in the block. null if pending.
* _**from\_address**_ - Address of the sender.
* _**to\_address**_ - Address of the receiver. null if it’s a contract creation transaction.
* _**value** _ - Value transferred in wei.
* _**gas**_ - Gas provided by the sender.
* _**gas\_price**_ - Gas price provided by the sender in wei.
* _**input**_ - The data sent along with the transaction.
* _**block\_timestamp**_ -  the unix timestamp for the block this transaction was in.
* _**max\_fee\_per\_gas**_ - the maximum amount of gas willing to be paid for the transaction (inclusive of baseFeePerGas and maxPriorityFeePerGas)
* _**max\_priority\_fee\_per\_gas**_ -  the maximum amount of gas to be included as a tip to the miner.
* _**transaction\_type**_ -  a number between 0 and 0x7f, for a total of 128 possible transaction types.

### Pricing Data

There are two types of exchanges on which the pricing data can be extracted -&#x20;

1. Centralized Exchanges (CEX)
2. Decentralized Exchanges (DEX)

While there are major differences between these two types of exchanges, we will only discuss the difference of the pricing data in these.

1. **Centralized Exchanges**

Centralized Exchanges work in a similar fashion as traditional stock exchanges do and report the prices in the native FIAT currencies. For example, a CEX based in the US will show the price of an asset in US Dollar and a CEX based in India will show the price in INR. These sources of information are out of scope for the purposes of the current article.

2\. **Decentralized Exchanges**

Decentralized Exchanges **mostly** work on "[Constant Product Principal](https://www.gemini.com/cryptopedia/amm-what-are-automated-market-makers#section-constant-product-formula)" and report the price of an asset in terms of another asset.

For example, WBTC-WETH pool on decentralized exchange, Uniswap will report the price of WBTC in terms of WETH and the price of WETH will be reported in WBTC.

To access the pricing data from both the sources, generally one of these two methods are followed

1. API call
2. Oracle call

#### API Call

To explain API Call method in this article, we will be using [Coingecko’s API](https://www.coingecko.com/en/api/documentation)&#x20;

First, we will fetch all the data of top 5000 assets (by market capitalisation) tracked by Coingecko using:

```
def fetch_market_data(vs_currency='usd', order='market_cap_desc', per_page='100', page='1'):
    COINS_MARKETS_URL = 'https://api.coingecko.com/api/v3/coins/markets?vs_currency={0}&order={1}&per_page={2}&page={3}'.format(vs_currency, order, per_page, page)
    resJs = requests.get(COINS_MARKETS_URL).json()
    # type(resJs)
    return resJs
```

This function, “fetch\_market\_data” will require two optional parameters vs\_currency, order, per\_page and page.

We will be using the US Dollar as default currency and the descending order by market capitalization as the default order to get pricing data.

These parameters will be passed in the Coingecko’s API link and the required response will be returned in JSON format.

However, maximum 100 results can be return in one page, so we have to loop through the 51 pages to get data of top 5000 coins, ordered by market cap in descending order.

```
# Looping through the first 5000 coins from Coingecko by market ranks and saving them in list, market_data.
market_data = list()
for i in range(51):
    data = fetch_market_data(page=i)
    market_data.extend(data)
    i += 1

```

The market\_data is a list of top 5000 assets with information tracked by Coingecko from current price and market cap to circulating supply and all time high and low prices.

Below is the example of returned response for Bitcoin (BTC):

![Coingecko Bitcoin Example](https://lh4.googleusercontent.com/m7wFFvhHpFIWdFEaFUpbYp0jcuINQ-IfoCDDCYbLRoE6P-U6VyrzyXypba6u1yYvGuGkdmIiVFct18AQ4L3cDIIiJt6pa9jCNjyxnBN3sp47hEOW1nnoah\_rVDETVVcw6-RMlScn)

Pricing data can also be fetched from using contract address in a specific API of Coingecko using the following code:

```
# To fetch the details of smart contract from Coingecko and return the current price
def fetch_price_from_contract_address(_chain, _contractAddress):
    URL = 'https://api.coingecko.com/api/v3/coins/{0}/contract/{1}'.format(_chain, _contractAddress)
    # print(URL)
    resJS = requests.get(URL).json()
    # return resJS
    usdPrice = resJS['market_data']['current_price']['usd']
    return usdPrice
```

#### Oracle Call

Oracle call is an on-chain data and information fetching method, mostly used by smart contracts to keep track of events happening outside the walls of blockchain.

This is an expensive approach when compared to API call approach as it requires the request of creation of smart contract for specific purpose of the user’s smart contract and rewarding validators and data providers to correct information.&#x20;

Prices can be fetched from different protocols for the asset prices. Most protocols have different methodologies to extract the data. As an example, we have included the sample file screenshots from extraction of ETH-USDC pair asset prices in the appendix below to understand the asset price data structure output across different protocols on-chain. Appropriate code sample is provided for some of the sources as an example in the **Appendix** section.

### Appendix

#### ETH-USDC Pricing across different protocols.

1. **Curve Finance**

The below code snippet will fetch the price of ether from Curve Finance’s API and store it along with the timestamp into the dataframe, df.

As only current price and timestamp is returned by this API, therefore this API call is looped after every 60 seconds and data is appended to dataframe.

```
ind = 0
df = pd.DataFrame(columns=['price', 'time'])
for i in range(10000):
    res = requests.get("https://api.curve.fi/api/getETHprice").json()
    if res['success']==True:
        df.loc[ind] = [res['data']['price']] + [res['data']['generatedTimeMs']]
        ind += 1
    time.sleep(60)
    if i % 100 == 0:
        print(i)
```

**1.a Data Sample Screenshot**

![Curve Finance Data Sample](https://lh5.googleusercontent.com/RFQhZwPxIISqLaKt7mmGRrmETOjvmdJ-cye8quC1\_JDOx75ux4emW8aO7f2WSL3LH10U-GfvDfiYiPTeS897KMv30wmMXthUby6uOBM32bbdLnJJaXBnBDykhoQ2b3SKOS2dZG0T)

**2. Sushiswap**

**2.a Data Sample Screenshot**

![Sushiswap Data Sample](https://lh5.googleusercontent.com/lM3PuGjChuexOIpZIktGW\_5ERi0ltUjte9LbDWwILvVjGA9RCxYcZwDXYRKpFzI5fyDn71p8D5u\_kujlppHHptZ4go1N\_bpm\_g5ECgnPwTournmUmRcdoTLT3u7PrJn5UgsAtKXG)

3\. **Uniswap V3**

The following code snippet will fetch the current tick and tick spacing from Uniswap V3 ETH-USD contract instance and calculate MIN\_TICK, MAX\_TICK, MIN\_PRICE, MAX\_PRICE using mathematical formulas also mentioned in [Uniswap V3’s whitepaper](https://uniswap.org/whitepaper-v3.pdf).

```
address = "0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640"
abi = etherscan_abi_request(address, ETHERSCAN_API_KEY )
contract_instance       = w3.eth.contract(address=address, abi=abi)

USD_DECIMALS = 6
ETH_DECIMALS = 18
ABS_DECIMALS = 12

CURRENT_TICK = contract_instance.functions.slot0().call()[1]
TICK_SPACING = contract_instance.functions.tickSpacing().call()
MIN_TICK = CURRENT_TICK -  CURRENT_TICK% TICK_SPACING 
MAX_TICK = MIN_TICK +  TICK_SPACING 

MIN_PRICE = 1 / (pow(1.0001, MAX_TICK) * pow(10,(USD_DECIMALS - ETH_DECIMALS )))
MAX_PRICE = 1 / (pow(1.0001, MIN_TICK) * pow(10,(USD_DECIMALS - ETH_DECIMALS )))
```

**3.a Data Sample Screenshot**

![Uniswap V3 Data Sample](https://lh4.googleusercontent.com/JoUlP1b1Vad-dwltwtmV0\_kINCLw3Dk--Ob8yftmryM6Tx-xA4iK4GJAWtoEaW175zjkyI9Q2bjPmuYQyI-8zaL6wpJrd4bZ-VQ3Qqp3ANYh8poPgU48eHZjWOJJ0JtiV-ESoTFo)

4\. **Aave V2**

The following code snippet will fetch the price of Ether in US Dollar from Aave’s Native API and is looped back to past 100 days from the START\_DATE.

```
df  =  pd.DataFrame(columns = ['Date', 'Prices'])
START_DATE    = datetime.strptime('12-12-2021', '%m-%d-%Y')
CURRENT_DATE  = START_DATE
EVERYDAY_DATA = {}
ind = 0
for i in range(100):
    res = requests.get('https://aave-api-v2.aave.com/data/liquidity/v2?poolId=0xb53c1a33016b2dc2ff3653530bff1848a515c8c5&date='+str(CURRENT_DATE.date())).json()
    EVERYDAY_DATA[str(CURRENT_DATE.date())] = res
    df.loc[ind] = [str(CURRENT_DATE)] + [EVERYDAY_DATA[str(CURRENT_DATE.date())][0]['referenceItem']['priceInUsd']]
    CURRENT_DATE = CURRENT_DATE - timedelta(1)
    print(CURRENT_DATE)
```

**4.a Data Sample Screenshot**

![Aave V2 Data Sample](https://lh4.googleusercontent.com/6nmpPVPvGKugPhEBB8n1BD33VkS7sZ3VrukETev1vKQ-ubJ3uaIfQThOl\_7JxfhSUNQku2czDkKEHi1A0dxm-hNhvdSV1mskRE\_lIa3oJhTNAbZS0sLR-o9UjWiESLUlxkr8\_vqs)

5\. **Compound V2**

**5.a Data Sample Screenshot**

![Compound V2 Data Sample](https://lh3.googleusercontent.com/O3DM10sLYJ-WTbkpM4owuECEvjPNi5a\_c-XVIAR\_c89liFIc9MZwOXcdeabbzL5czCzKhwTc7C\_gGj0u--Z6czOzSJoGGPaK3yRzmrR6zsKJhgBTOtKVRlnvux2jfx1TFzrxM1lW)

**6. Balancer**

**6a Data Sample Screenshot**

![Balancer Data Sample](https://lh3.googleusercontent.com/6wDFPIjq3DKabPCRQDB-uH-WZSucP1-Q-X6VhgAY33HtKZcFd\_GVhKeJkhSFrwmcwWdvC-UBiVvDL7193XUwSOEH7naW3XDIM8wFXkgyEAhH9u-xrhYLk4glUlR7lymZWL-d8VfN)

7**. Chainlink**

The following code snippet will fetch the Ether price in US Dollar using Chainlink oracle. First a contract instance is established for the contract address of ETH-USD oracle and web3.py library.

After that the latest round number is fetched using  latestRoundData and looped in reverse order to get pricing information using getRoundData until a predefined stop date.

```
chainLinkOracleDic = {"eth-usd": "0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419", 
                        "btc-usd":"0xf4030086522a5beea4988f8ca5b36dbc97bee88c",
                        "link-usd": "0x2c1d072e956affc0d435cb7ac38ef18d24d9127c",
                        "usdt-usd": "0x3e7d1eab13ad0104d2750b8863b489d65364e32d",
                        "dai-usd": "0xaed0c38402a5d19df6e4c03f4e2dced6e29c1ee9",
                        "dai-eth": "0x773616e4d11a78f511299002da57a0a94577f1f4"
                       }

address = chainLinkOracleDic["eth-usd"]
test_res_v2 = etherscan_abi_request(address, ETHERSCAN_API_KEY )
address_CONTRACT_INSTANCE = w3.eth.contract(address = address, abi=test_res_v2)
#roundID contains latestRound (pos 0) and latestAnswer (pos 1) and updatedAt (pos 3)

latestRoundData = address_CONTRACT_INSTANCE.functions.latestRoundData().call()

latestRound = latestRoundData[0]
latestAnswer = latestRoundData[1]
latestTime = latestRoundData[3]


decimals = address_CONTRACT_INSTANCE.functions.decimals().call()

#collect data from latestRound until stopDate

df = pd.DataFrame(columns=['round', 'prices', 'updated at'])

ind = 0

stopDate = datetime.datetime(2021,10,1)

for i in reversed(range(latestRound)):
    roundData = address_CONTRACT_INSTANCE.functions.getRoundData(i).call()
    dateTime = datetime.datetime.fromtimestamp(roundData[3])
    answer = roundData[1] 
    if dateTime >= stopDate:
        df.loc[ind] = [i] + [np.divide(answer, 10**decimals)] + [dateTime]
        ind += 1       
    else:
        break
```

**7.a Data Sample Screenshot**

![Chainlink Data Sample](https://lh4.googleusercontent.com/6vpq\_l6coDHbZN50kd1\_RicpH4VFVhwXKypduOkh3iOidh9rNnc7v8FUD1DSDHD\_SEPXFPA9BSEtGl7n4XmZf39DROgXkXUFitlRGoBe7G\_eZkrd3voffS50KBAmSzkEsi915OEr)

### Glossary

1. **Trie,** also called Radix Trie, Patricia Trie, or Prefix Tree, is a data structure which is fastest at finding common prefixes, simple to implement, and requires small memory. As Ethereum uses Merkle Tree to efficiently store the hash in blocks, Trie is used as a core data structure of data storage.
2.  **Constant product formula**: x \* y = k, where x is the amount of Token#1 in the liquidity pool, y is the amount of Token#2 in the liquidity pool, and k is a fixed constant.

    Price of Token#1 will be calculated in terms of Token#2 according to their respective quantity in the pool while maintaining the constant product of both tokens’ quantity.
